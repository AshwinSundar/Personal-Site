{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/parallel-processing-rust/parallel-processing-rust/",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Parallel Processing in Rust","date":"April 2022","hero_image_alt":""},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Parallel Processing in Rust\",\n  \"date\": \"2022-04-02\",\n  \"hero_image\": \"\",\n  \"hero_image_alt\": \"\",\n  \"publish\": 1\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.rust-lang.org/\"\n  }, \"Rust\"), \" is a systems programming language that is quickly gaining traction at well-known companies including Amazon, Discord, Dropbox, Meta, Alphabet, and Microsoft. It is built for \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.rust-lang.org/\"\n  }, \"performance, reliability, and productivity\"), \" and has been voted the most loved programming language according to Stack Overflow's \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://insights.stackoverflow.com/survey\"\n  }, \"Annual Developer Survey\"), \" since 2016. Some large-scale commercial projects that have been built using Rust include:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Mozilla's \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://servo.org/\"\n  }, \"Servo\"), \" parallel browser engine\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Discord's \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f\"\n  }, \"Read States\"), \" service\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Polkadot's \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/paritytech/polkadot\"\n  }, \"Substrate\"), \" blockchain engine\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Figma's \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.figma.com/blog/rust-in-production-at-figma/\"\n  }, \"Multiplayer\"), \" service\")), mdx(\"p\", null, \"All of these real-world use cases of Rust utilize and benefit from concurrent and parallel processing, which can be daunting to implement on a good day, and pretty terrifying when implemented \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Therac-25\"\n  }, \"badly\"), \". Rust helps mitigate concurrency hazards by design, but it's still up to the programmer to construct their program logic thoughtfully so they can take advantage of the power of concurrent and parallel processing.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"When should I use concurrent or parallel processing, instead of serial processing?\")), mdx(\"p\", null, \"Most modern processors have multiple cores to work with, which means you can use these cores to achieve significant performance gains:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When you have a lot of independent computations to process, such as a giant for-loop.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When some of your threads contain computations that are particularly lengthy to calculate. It's nice to run these on the \\\"backburner\\\" without blocking your program from performing other computations.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When you have low \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.mathworks.com/help/parallel-computing/decide-when-to-use-parfor.html\"\n  }, \"parallel overhead\"))), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"How do I implement parallel processing in Rust?\"), \"\\nMy favorite way to learn new programming languages is by combining it with my love for math and solving problems in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://projecteuler.net/\"\n  }, \"Project Euler\"), \". To demonstrate parallelization in Rust, let's solve a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://projecteuler.net/problem=1\"\n  }, \"simple problem\"), \" that I tweaked slightly so we can focus on the implementation of our solution:\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1,000,000.\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Solution Methodology\"), \"\\nWhile the mathematically elegant solution would be to use an \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Arithmetic_progression\"\n  }, \"arithmetic series\"), \", let's just focus on the simple solution, which is to figure out if each number in the range is divisible by 3 or 5. If it is, let's add it to a running sum we're keeping track of.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Example 1 - No parallelization\")), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"rust\",\n    \"terminal\": \"none\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"fn euler1_unpar(input: i32) -> i64 {\\n    let mut sum: i64 = 0;\\n    for i in 1..input {\\n        if i % 3 == 0 || i % 5 == 0 {\\n            sum += i as i64;\\n        }\\n    }\\n    sum\\n}\"), \"\\n        \"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Code walkthrough:\"), \" In this example, we accept an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"input\"), \", and iterate on every number between \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1..input\"), \" to determine if it is divisible by 3 or 5 using the modulo \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"%\"), \" operator. If it is, then add the value to a running \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sum\"), \" we're keeping track of. At the end, return the sum. In Rust, you can return a value by simply calling it without a semicolon after the expression. Since Rust is a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Strong_and_weak_typing\"\n  }, \"strongly-typed\"), \" language, we need to tell the compiler to add the original \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i32\"), \" input and convert the sum to an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i64\"), \", so that we have enough space to store the answer.\"), mdx(\"p\", null, \"Let's calculate a performance benchmark for this function so we can compare it to our multithreaded optimization that we'll write next. We can calculate this benchmark with the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.rs/easybench/latest/easybench/\"\n  }, \"easybench\"), \" crate, an importable package in Rust.\"), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"rust\",\n    \"terminal\": \"none\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"use easybench::{bench};\\nlet input = 1000000;\\nprintln!(\\\"euler1_unpar: {}\\\", bench(|| euler1_unpar(input) ) );\\n\\n>> euler1_unpar: 14.429298ms (R\\xB2=0.999, 70 iterations in 21 samples)\"), \"\\n        \"), mdx(\"p\", null, \"Our unparallelized function takes about \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"14.4\"), \" milliseconds to execute.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Example 2 - Parallelized (2 threads)\")), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"rust\",\n    \"terminal\": \"none\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"fn euler1_par(input: i32) -> i64 {\\n    use std::thread;\\n\\n    let handle1 = thread::spawn(move || {\\n        let mut thread1_sum: i64 = 0;\\n        for i in 1..input / 2 {\\n            if i % 3 == 0 || i % 5 == 0 {\\n                thread1_sum += i as i64;\\n            }\\n        }\\n\\n        thread1_sum\\n    });\\n\\n    let handle2 = thread::spawn(move || {\\n        let mut thread2_sum: i64 = 0;\\n\\n        for i in (input / 2)..input {\\n            if i % 3 == 0 || i % 5 == 0 {\\n                thread2_sum += i as i64;\\n            }\\n        }\\n\\n        thread2_sum\\n    });\\n\\n    handle1.join().unwrap() + handle2.join().unwrap()\\n}\"), \"\\n        \"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Code walkthrough:\"), \" Here, we use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"thread\"), \" module so that we can take advantage of the native multithreading available in Rust. A new thread is created by calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"thread::spawn\"), \", into which a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"closure\"), \" is passed. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://doc.rust-lang.org/book/ch13-01-closures.html\"\n  }, \"Closures\"), \" are anonymous functions that allow you to access environment variables, such as the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"input\"), \" variable. This closure does the same mathematical computation as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"euler1_unpar\"), \", except we only process one half of the total range in the thread. The other half is saved for the second thread. We also need to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"move\"), \" a copy of the input into the closure's scope so that the thread can take ownership of the data and use it. Writing code like this can seem tedious and time-consuming, but is required by Rust to help reduce the risk of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://doc.rust-lang.org/book/ch16-00-concurrency.html\"\n  }, \"concurrency errors\"), \".\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"thread::spawn\"), \" returns a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JoinHandle\"), \" type, which contains some convenience methods that allow us to take back control over the threads and handle their results. In this case, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JoinHandle::join()\"), \" halts execution of the function until our threads have finished their calculations. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".unwrap()\"), \" exposes the answers we've calculated in each thread, and then finally we sum those answers up.\"), mdx(\"p\", null, \"Let's see how long this function takes to run:\"), mdx(\"deckgo-highlight-code\", {\n    \"terminal\": \"none\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"use easybench::{bench};\\nlet input = 1000000;\\nprintln!(\\\"{}\\\", euler1_par(input));\\n\\n> euler1_par:  7.345441ms (R\\xB2=0.998, 133 iterations in 27 samples)\"), \"\\n        \"), mdx(\"p\", null, \"The parallelized function takes about \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"7.3\"), \" milliseconds to execute.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Conclusion\"), \"\\nThe parallelized code runs almost twice as fast as our unparallelized code, and we seem to only lose a little performance due to the overhead of setting up the threads. Nice!\"), mdx(\"p\", null, \"This example demonstrates a way to get started with parallel processing in Rust. You often need to design your program with parallelization in mind from the get-go, as you are forced to think about the flow of your code and determine what pieces of the code take the longest to run and would benefit from parallelization.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"This article was originally written for the \", mdx(\"a\", {\n    parentName: \"em\",\n    \"href\": \"https://engineering.deptagency.com/parallel-processing-in-rust\"\n  }, \"engineering blog\"), \" at DEPT\\xAE, a technology consultancy\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"fba625a4-13d9-55c8-93f0-7285250354a7","slug":"parallel-processing-rust/parallel-processing-rust","__params":{"slug":"parallel-processing-rust"}}},
    "staticQueryHashes": ["2928772754"]}