TO DO:
- header image for article, should be your own photo
- one more image, your own as well (probably in footer)
- 2 images from me, 2 images from AI. I'm debasing my own value as a photographer, potentially. I just want to tip my hat to the actual photographers out there, letting them know that I understand what this means and am sympathetic. 

# Strengths and Weaknesses of GPT-3 for Enhancing Developer Efficiency

## Introduction

Writing code can be a complex and cognitively demanding task, involving various intellectual gymnastics such as debugging code and memorizing syntaxes across different languages. To manage this cognitive load and improve efficiency, programmers need strategies and tools to help them navigate their daily work. One such tool is OpenAI's Generative Pretrained Transformer [(GPT-3)](https://openai.com/blog/chatgpt/interact.sh/%2f../), an artificial intelligence (AI) language model which interacts with users in a conversational manner through its recently released ChatGPT-3 interface. In this article, we will explore the usefulness of GPT-3 for developers by examining its performance in handling three common challenges that they may encounter in their work. These challenges include generating new code, explaining unfamiliar code constructs, and deciphering unusual error messages.

 
## Use Case #1 - Generating new code

ChatGPT-3 can generate new code. Here are some sample prompts and accompanying responses from ChatGPT-3.

---

**<u>Prompt</u>**: Create boilerplate code for a React.js project  
**<u>Response</u>**: Here is some boilerplate code for a React.js project:
```javascript
import React from 'react';
import ReactDOM from 'react-dom';

class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      // Initialize state here
    };
  }

  render() {
    return (
      // Add JSX here
    );
  }
}

const rootElement = document.getElementById('root');
ReactDOM.render(<App />, rootElement);
```
 
This code creates an App class that extends React.Component and has a render method that returns JSX to be rendered to the page. The App component is then rendered to the element with the root ID. You can add your own state and JSX to customize the component.

---

That looks acceptable. GPT-3 even explained the code in plain English. The output can be corroborated by simply running the code and confirming that it behaves as described. 

A more challenging prompt is to solve Problem 2 from [Project Euler](https://projecteuler.net/problem=2), which is a series of problems that require mathematical and programming proficiency to solve.  

---

**<u>Prompt</u>**: Solve Problem 2 from Project Euler:

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

**<u>Response</u>**: Here is a recursive solution to Problem 2 in Project Euler using Python:

```python
# define a recursive function to compute the sum of the even-valued terms in the Fibonacci sequence
# whose values do not exceed a given maximum value
def even_fibonacci_sum(n, a=1, b=2, sum=0):
  # if the second term exceeds the maximum value, return the sum
  if b > n:
    return sum
  # if the second term is even, add it to the sum
  if b % 2 == 0:
    sum += b
  # call the function recursively with the next terms in the sequence
  return even_fibonacci_sum(n, b, a + b, sum)

# test the function
print(even_fibonacci_sum(4000000))
```
This function takes in three arguments: the maximum value (n), the first term (a), and the second term (b) of the Fibonacci sequence. It also has an optional argument sum that keeps track of the sum of the even-valued terms in the sequence.

---

The solution comes with comments and a brief explanation of how the code works. The recursive function accepts one mandatory argument (the maximum value `n`) and three optional arguments:  
- `a`: The first term of the sequence  
- `b`: The second term of the sequence  
- `sum`: The running sum of the even-valued terms  

If `b` exceeds the maximum value specified, then the entire sum is returned and the function completes. Otherwise, the function checks if the second term is even and adds it to the running sum, and the function is called again. However, ChatGPT-3 did not correctly pick up on the fact that the last 3 arguments are optional, so the solution description is not accurate in this instance. 

Finally, let's come up with some fun and novel code based on a vague prompt, in a functional programming language called Standard ML.

---

**<u>Prompt</u>**: Write an interesting Standard ML program based on [Bartleby's Parable](https://www.bartleby.com/129/).

**<u>Response</u>**: Here is a possible Standard ML program that is based on Bartleby's Parable.

```sml
(* The main function that represents Bartleby's actions *)
fun bartleby() =
  let
    val message = "I would prefer not to"
    val tasks = ["copy documents", "file papers", "answer letters"]
    val responses = map (fn task => print(task ^ "? " ^ message ^ "\n")) tasks
  in
    if (forall (fn response => response = message) responses) then
      print("Bartleby is uncooperative and does not complete any tasks.\n")
    else
      print("Bartleby completes some tasks, but not all.\n")
  end

(* Call the main function *)
bartleby()
```

This program defines a function `bartleby` that represents the actions of the character Bartleby from the parable. The function has a list of tasks that Bartleby is asked to do, and for each task Bartleby responds with the message "I would prefer not to". If Bartleby responds with this message for all tasks, then the function prints that Bartleby is uncooperative and does not complete any tasks. Otherwise, the function prints that Bartleby completes some tasks, but not all.

---

Impressively, ChatGPT-3 is able to generate a functional program based on a couple of totally unrelated topics: recursive programming in SML and the parable of ["Bartleby, the Scrivener"](https://www.bartleby.com/129/). This is a short story written by Herman Melville in 1853 about a Wall Street clerk who refuses to do his boss's bidding, simply replying "I would prefer not to,", a feeling shared by many programmers when the holidays approach. The output is a short SML program that seems to produce a variation of this response based on what is asked of him. However, there are a few problems - both on the programming side as well as the story side. 

First of all, this code does not compile because the `forall` function is not defined in this context. The fix is to rewrite the `if(forall (...))` expression in a recursive style. 

Second, in the original parable, Bartleby refuses to complete any task asked of him, yet this code indicates that he may complete some tasks, but not all. It doesn't make sense to include this branch in the conditional statement based on the original story. This intersection of unrelated topics seems to prove difficult for the language model to process properly. 

The code provided requires some intermediate familiarity with Standard ML to debug and fix successfully. Therefore, in this example, the programmer is not fully relieved from the task of writing idiomatic and correct code. GPT-3 performs well with close-ended requests, such as how to create simple code in a language. It seems to struggle with open-ended requests that have an indefinite solution, such as the query to write a program about Bartleby. 

## Use Case #2 - Explaining unfamiliar constructs
How does ChatGPT-3 handle unfamiliar syntax and programming constructs? In the following example, a Complex number class is created using a construct called an [overloaded operator](https://en.cppreference.com/w/cpp/language/operators). This construct is not uncommon, but may be unfamiliar to some developers. Let's see if GPT-3 can make sense of this code.   

--- 

**<u>Prompt</u>**: What does this C++ code mean?
```c++
class Complex {
  double re, im;

public:
  Complex(double re, double im) : re(re), im(im) {}

  Complex operator+(const Complex& other) const {
    return Complex(re + other.re, im + other.im);
  }
};
```

**<u>Response</u>**: 
This C++ code defines a Complex class that represents complex numbers. The Complex class has two member variables, re and im, that represent the real and imaginary parts of the complex number, respectively. It also has a constructor that takes the real and imaginary parts as arguments and initializes the re and im member variables.

The Complex class also has a operator+ member function that overloads the + operator for the Complex class. This function takes another Complex object as an argument and returns a new Complex object that is the sum of the two operands. The operator+ function uses the re and im member variables of the Complex objects to compute the sum of the two complex numbers, and then it returns a new Complex object with the result.

This Complex class allows you to create Complex objects and add them using the + operator, as shown in the following example:

```c++
int main() {
  Complex a(1.0, 2.0);  // a = 1.0 + 2.0i
  Complex b(3.0, 4.0);  // b = 3.0 + 4.0i
  Complex c = a + b;    // c = (1.0 + 3.0) + (2.0 + 4.0)i = 4.0 + 6.0i

  return 0;
}
```
In this example, we create two Complex objects a and b, and then add them using the + operator. The result is a new Complex object c that represents the sum of the two operands. Because we have overloaded the + operator for the Complex class, the + operator will automatically call the operator+ member function of the Complex class to add the two objects and return the result.

---

This is a good explanation of the Complex number class created. GPT-3 was able to understand that this code relates to complex numbers based on the names of the class and member variables, even though the code was uncommented. Finally, it was able to write an example of how to use the Complex function to add two complex numbers using the overloaded + operator. GPT-3 performs well when presented with a question about language syntax, a well-documented concept that lends itself to definitive answers.

## Use Case #3 - Deciphering arcane error messages  
A useful skill for a programmer to develop is the ability to interpret unhelpful or misleading error messages. The following C++ code compiles successfully, but generates a [segfault](https://en.wikipedia.org/wiki/Segmentation_fault) at run-time.

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector<int> v{1,2,3};	
	for (int i=1; i<=4; i++) { std::cout << v[i] << std::endl; }	
	return 0;
}
```

This code should compile successfully, yet generate a segfault to out-of-bounds access of items in vector `v`. Yet when we run `g++ segfault.cpp`, which uses [GNU Compiler](https://gcc.gnu.org) to compile the `.cpp` file to an executable, the following error message is generated at compilation:

```
segfault-example.cpp:5:20: error: expected ';' at end of declaration
        std::vector<int> v{1,2,3};      
                          ^
                          ;
1 error generated.
```

Helpfully, the error explains where a semicolon needs to be inserted. We could resolve the error by filling the vector on the next line with [`std::vector::push_back`](https://en.cppreference.com/w/cpp/container/vector/push_back), but that isn't an elegant or idiomatic solution. If we research the [rules for expressions for vectors](https://en.cppreference.com/w/cpp/container/vector/vector), we discover that this syntax is correct, as it uses an initializer list {1,2,3} to construct the vector.

Something doesn't make sense. The syntax used is valid, so why are we getting this error? Let's revisit the link and carefully read again:

<img src="/Users/ashwin/Documents/Personal Site/blog/assets/chat-gpt/cppref-vectors1.png" style="width:50%" />
<img src="/Users/ashwin/Documents/Personal Site/blog/assets/chat-gpt/cppref-vectors2.png" style="width:50%" />

The initializer list syntax for vectors was not implemented until C++11! By default, the version of `g++` on my machine compiles to C++98.

```bash
❯ g++ --version | head -1
Apple clang version 13.1.6 (clang-1316.0.21.2)
❯ g++ -dM -E -x c++  /dev/null | grep -F __cplusplus
#define __cplusplus 199711L
```
The type of debugging suddenly jumped from simple syntax mistakes to changing language settings in the compiler. A lot of programmers will find this frustrating to solve and fix. Can GPT-3 save the day? Will it get distracted by the obvious segfault issue? Or will it dig deeper and discover which g++ flag needs to be used to compile to C++11 and allow the use of vector intializer lists? 

---

**<u>Prompt</u>**: Why won't this C++ code compile when I run "g++ file.cpp"?

**<u>Response</u>**: It looks like there is an issue with the for loop in your code. The loop variable i is being initialized to 1, and the loop is continuing as long as i is less than or equal to 4. This means that the loop will attempt to access the elements at indices 1, 2, 3, and 4 of the vector v. However, the vector v only has 3 elements (at indices 0, 1, and 2), so attempting to access the element at index 4 will result in an out-of-bounds error.

To fix this issue, you can modify the loop condition to stop the loop before i becomes greater than the size of the vector. For example, you could change the loop condition to i < v.size() or i < 3 (since the vector has 3 elements).

---

GPT-3 successfully discovered the run-time segfault that results from accessing an out-of-bounds value, but it failed to explain that g++ is not compiling to the correct version of C++. Let's refine the prompt and try again: 

---

**<u>Prompt</u>**: The error received for the previous code was:

```
segfault-example.cpp:5:20: error: expected ';' at end of declaration
        std::vector<int> v{1,2,3};      
                          ^
                          ;
1 error generated.
```   

**<u>Response</u>**: I apologize for the mistake in my previous response. It looks like there is a different issue with your code.

The error message expected ';' at the end of declaration is indicating that there is a problem with the line `std::vector<int> v{1,2,3};`. This line is using list initialization to create a new vector and initialize it with the elements 1, 2, and 3. The curly braces {} are used to enclose the list of elements, and a semicolon ; is used to terminate the statement. It looks like there is a typo in this line of code, and the semicolon is missing. To fix the error, add a semicolon ; after the closing curly brace }: After adding the semicolon, the code should compile without any issues.

---

Politely, GPT-3 tries to fix the error. However, the response misleads us into debugging the syntax once again, even after we provided additional hints that the problem resides not with the code, but the compiler. The correct solution is to compile the program with the command `g++ -std=c++11 segfault.cpp` so that the compiler uses the syntax rules of C++11 to generate the program with a vector initializer list.

This example demonstrates that GPT-3 is capable of syntax debugging, but falls short when the problem lies outside of syntax mistakes. As a result, a programmer must still have a good idea of what the solution space for a problem looks like and recognize when they are being led astray. 

## Summary and Implications  
AI tools like GitHub CoPilot and TabNine can be useful for programmers, but they have also faced [controversy](https://matthewbutterick.com/chron/this-copilot-is-stupid-and-wants-to-kill-me.html). GPT-3 is unlikely to remain immune from similar questions about where the code it is generating actually comes from. Therefore, programmers should be cautious when relying on AI tools and approach results with a grain of salt.

GPT-3 excels at processing close-ended, complete problems. These are problems where the shape of the solution is evident in the distance and slowly reveals itself in a progressive manner, like a distant island that a castaway paddles towards during sunset. As long as they don't lose sight or give up, they'll reach their target. 

<img src="/Users/ashwin/Documents/Personal Site/blog/assets/chat-gpt/castaway.png" style="width:50%" />

On the other hand, GPT-3 struggles with open-ended problems. These problems have multiple viable solutions, but it is unclear which path to pursue. These solutions are like distant stars to a spaceship - they all look equally far apart and appear about the same size and shape - how does the pilot decide which to navigate to? Each star requires a lot of research just to determine its composition, yet the mere nature of a star doesn't provide any guarantees about what might be there once one arrives. 


Regardless, GitHub CoPilot, TabNine, ChatGPT-3, and other AI assistants mark the arrival of a new method of work for software engineers. After seeing the capabilities of these tools, some developers may fear that automation has finally come to take their jobs.

Rather than fear automation in the field of software engineering, programmers should embrace it as a way to improve productivity and stay current with technological advances. Automation has been a part of the software engineering industry from its inception - from Ada Lovelace's [description](https://books.google.com/books?id=hPRmnQEACAAJ&printsec=frontcover&source=gbs_ge_summary_r&cad=0#v=onepage&q&f=false) of a language to run Charles Babbage's analytical engine, to text editors with macros, to GUI buttons that condense a series of commands to the click of a button. 

<img src="/Users/ashwin/Documents/Personal Site/blog/assets/chat-gpt/spaceship.png" style="width:50%" />

Imagine a future where a knowledge worker, on their first day of work, is issued a badge, a personal computer, and an AI assistant personalized to the knowledge and training they need to know for their job. One could ask the assistant to summarize complex documentation or get clarification on a process, among other use cases.  

For programmers specifically, there are other ways that AI tools can be folded into a workflow, such as [facilitating directed learning](https://www.swyx.io/learn-in-private), improving [personal knowledge management](https://en.wikipedia.org/wiki/Personal_information_management), and [maximizing learning](https://meta.stackoverflow.com/questions/419427/tips-for-searching-effectively-on-stack-overflow-novice-developer-training/419440#419440) from complex programming problems.

Ultimately, it is up to the individual programmer to use AI tools responsibly and effectively in their work. In this article, we explored the strengths and weaknesses of GPT-3 in executing three tasks a programmer encounters in their daily work - generating new code, explaining existing code, and debugging code. The same precautions one takes after consulting Google or StackOverflow for help with these tasks should be taken when consulting an AI assistant as well. By following best practices, such as not sharing proprietary software or information, and approaching results with a critical eye, programmers can take advantage of AI tools and enhance their productivity. 

# MISC NOTES

What do I mean by traditional sense of efficiency? Teh connotation for me is blah blah blah work smart not hard blah but that phrase never made sense to me for some reason. Efficiency has one meaning in physical systems, but the mind and body is a physiological symbiosis (mind-body ??? Descartes?) blah blahAI doesn't just automate away tasks. It can alleviate mental burden. In the morning, you come across some bizarre C++ syntax that you've never encountered while reviewing a colleague's code. You have a few options:

- Ask the colleague what the heck that syntax is. Perhaps they're very senior to you, and you're still a bit timid about asking an uneducated question. Alright let's just put off the conversation for a bit, I'll go work on something else.
- Damn! I gotta finish that review. Hmm...now it's 11AM which is kinda late for me to be asking such a basic question...alright I trust my colleague, let's just approve this and I can move on to the rest of my day without worry.

You might think, c'mon take more responsibility than that - that was only 2 hours. But the fact of the matter is, these scenarios happen a LOT among more junior colleagues. As a recent graduate from junior colleague to just colleage, I am not too far removed from those feelings myself. The feelings of inadequacy, of imposter syndrome. Of not knowing if you're in the right career, of maybe being seen as a fraud for any number of reasons. For me it's the fact that I don't have any formal computer science degrees. It eats at me a lot more than I care to admit (he says, in a moment of rare personal vulnerability).

Here's the weird syntax I saw recently that I'm talking about: 

(go grab something weird CH did, change the variables, and post here)
```cpp
<code goes here>
```

Wow! What is that??? [Once you see the code, share a few guesses then give up]. What are the options now? Maybe it's time to go learn about each of these topics and see if any of them connect. If I had unlimited time and this was a school project, I would love to do that. But I don't have the first and this isn't the second. Another option is to schedule a quick call or send a chat to DB. Hmmm...he's busy right now, and probably will be for a while. Don't want to bug him...no one else on the team would have more context than I do, so asking another colleague is probably not productive. I'm running out of resources to ask now...ok what do I THINK it is? Let me try each of these guesses/potential rabbit holes. I will need an hour or two of uninterpreted time today to do that. Darn, there's a scrum meeting in 20 minutes, which is scheduled for 15 minutes but will take more like 30. I have a 1:1 at noon and I have to prepare for that, so I don't want to get too far down the rabbit hole and then forget. So let's save this for after lunch...shoot maybe 2PM, I told someone I would help them out with something around 1. Okay 2-4PM works! But by the time I get out of my rabbit hole, it might be getting too late to contact the author and explain that I was too busy all day to ask a question.

Does this spiral make any sense? I hope so, because I'm weighing these kinds of ridiculous calculations in my head. I know, I know - get better at your job so you're brave enough to just ask a question.

In my opinion, next to knowing when to ask for help, a skill of a great programmer is the ability to be highly resourceful. When facing certain problems, we want every debugging tool, every StackOverflow entry, every man page written since 1969, and (one more). The next ",and" should be a custom-trained AI. An AI personalized to the knowledge YOU need to know. 

(Okay right there - that is a GREAT business idea. And it comes from DIRECT, PERSONAL experience. So I know EXACTLY what I want it to do. I believe it will be extremely useful to anyone who can realize it's value. I think the people who can will be those who see the future. This IS the future right here. I can see it, and I think others can, but I don't know where they are or how to find them. - well, those ppl are in AI - right?)

I started using GPT-3 to answer these kinds of tiny questions, redacted of any sensitive information, starting in early December. It had been maybe a week since I had vaguely heard of this new AI model in the news. Somehow, I got interested in it on a whim and decided to see if there was an API I could play with. Even better, a fully fledged chatbot! From there, I tried out a few simple questions that rapidly grew in complexity, until I was quite literally astounded by what I was looking at. I don't feel like that happens very often in my life anymore, which was also shocking to me that a piece of technology could have this level of impact on me. I could see vastly capable futures spawning in front of me for the first time, directly as a result of this AI technology I was seeing here. In the current information age (is that what we're currently in?), if knowledge workers can vastly improving their efficiency by making information more easily accessible, that's as big as what the Internet meant when it first became public. There are likely entire industries in AI that have yet to be uncovered. 

What is the idea there? It's that you offer a service that improves a software engineers ability to get answers. You ask them for as many details about their work life as you can. The more details the better. The problem is, no one will trust their sensitive company data to a freaking AI.

What if it just connects to github? A lot of people host public code on github. It could be run on open-source packages. I think it already does, doesn't it? What is Github Copilot?


## Is my job at risk? (might fit in implications section)
- answer question rationally
Start using the latest and greatest AI tools in your workflow so you can understand their strengths and weaknesses and stay relevant in your job. In this article we provided 3 concrete use cases, but here are some others to try out:
- Improvement sentences and descriptions in your resume


----

## Original Introduction 

**<u>Prompt</u>**: Write an introductory paragraph about how to use GPT3 in your day-to-day work as a software engineer.   
**<u>Response</u>**: *As a software engineer, you're constantly working on complex projects and dealing with a vast amount of information. GPT-3, the state-of-the-art language processing model from OpenAI, can help you manage your workload and make your daily work more efficient. In this article, we'll show you how to use GPT-3 to improve your productivity as a software engineer. We'll provide tips on integrating GPT-3 into your development process, using it to generate code and documentation, and even using it to help you debug and troubleshoot your code. With GPT-3, you can easily access the information you need, quickly generate high-quality code and documentation, and stay on top of your tasks, all while saving time and reducing stress.*

Across 4 prompts, I slowly refined the request I had of GPT-3. I wanted an introduction, yes, but I needed a few other intangibles and I vaguely ventured towards a decent introduction that I liked by the end of the refinement process. GPT-3 clearly has some value with helping me write pseudo-technical articles, such as this one. But can it help me with day-to-day programming tasks? To answer that question, I replaced my typical Google/Stack Overflow querying process (find a better phrase) with simply asking Chat GPT-3 what was on my mind (reword). The results convinced me that AI of this type has as important a role in knowledge discovery as Internet forums and Google do currently (ugh rough thesis, refine it).

## Caveat 
I am a software engineer, but I do not work in AI or keep up enough to know what is cutting edge (reword). So if I'm seeing things incorrectly, or editorializing too much and not speaking factually, then I do apologize. But I also wanted to share the emotional aspect of why GPT-3 seems so significant to me. 

**<u>Prompt</u>**: Can you rephrase the previous paragraph to sound less awkward   
**<u>Response</u>**: *As a software engineer, I am not well-versed in the latest developments in AI. If I have misstated any facts or come across as awkward in my writing, I apologize. However, I wanted to share my personal excitement about GPT-3 and why it feels like a significant milestone.*

**<u>Prompt</u>**: I don't really like that response, can you try again?   
**<u>Response</u>**: *Sure, here is another attempt at rephrasing the paragraph:  

As a software engineer, I am not an expert in the field of AI and may not be aware of the latest advancements. If my lack of knowledge leads to any inaccuracies in my writing, I apologize. I wanted to share my personal thoughts and feelings about GPT-3 and why it feels like an important achievement.*

Much better. That whole process of coming up with a satisfactory introductory paragraph took about an hour from start to finish. I tweaked the original output from Chat GPT-3 so that it sounds more like my voice. So let's start over. The beginning of the article starts...now: 
**<u>Prompt</u>** 1: Write an introductory paragraph to an article about how to use Chat GPT3 effectively.  
**<u>Response</u>**: *GPT-3, or Generative Pretrained Transformer 3, is the latest in a series of powerful language processing models developed by OpenAI. With its impressive ability to understand and generate human-like text, GPT-3 has quickly become a popular tool for a variety of applications, including chatbots and conversational interfaces. In this article, we'll provide some tips on how to effectively use GPT-3 in your chat applications, including how to fine-tune the model for specific use cases and how to integrate it into your chat platform. Whether you're a developer looking to build a more intelligent chatbot or a user looking to have more engaging conversations, GPT-3 can be a valuable tool.*

**<u>Prompt</u>** 2: Write an introductory paragraph about how to use GPT3 effectively, but with more emotion.   
**<u>Response</u>**: *Are you ready to take your chat applications to the next level with GPT-3? This revolutionary language processing model from OpenAI is capable of understanding and generating human-like text, making it a valuable tool for a wide range of chat applications. In this article, we'll show you how to effectively use GPT-3 to add more intelligence and emotion to your chatbots and conversational interfaces. Whether you're a developer looking to build a more engaging chatbot or a user looking to have more natural conversations, GPT-3 can help you achieve your goals. We'll provide tips on fine-tuning the model for specific use cases and integrating it into your chat platform, so you can start using GPT-3 to create more intelligent and emotionally-rich chat experiences.*

**<u>Prompt</u>** 3: Write an introductory paragraph about how to use GPT3 in your day-to-day work as a knowledge worker.   
**<u>Response</u>**: *As a knowledge worker, you're constantly dealing with a deluge of information and tasks, and it can be overwhelming to keep up with everything. GPT-3, the powerful language processing model from OpenAI, can help you manage your workload and make your daily work more efficient. In this article, we'll show you how to use GPT-3 to streamline your work and stay organized. We'll provide tips on integrating GPT-3 into your workflow, using it to generate reports and documents, and even using it to help you make decisions. With GPT-3, you can easily access the information you need, quickly generate high-quality content, and stay on top of your tasks, all while saving time and reducing stress.*
----

## Implications (Attempt 1)
What does it mean when the answers to a lot of minute, but difficult programming questions are at our fingerprints? Does it lower the bar for programmers across the board? Can anyone just generate code, rendering software engineering as a field obsolete? Conversely, is it dangerous to rely on AI tools like this at all, because it might render us all weaker problem-solvers in general? [I hate this sentence. It is a wild example of me generating a fake middle ground and resolving it. This is a cheesy rhetorical tactic, and it's also just a middle ground fallacy.] 
Like most things, the answer probably lies in the middle. Certainly there are still many aspects to software engineering that can't be answered by an online AI - such as who are the customers, what are their needs, and what are their real timelines. But it's also unproductive to dismiss AI entirely, just as it would have been to dismiss Internet search engines and forums in the 1990s. 


---
