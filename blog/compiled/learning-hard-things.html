<!-- Generated by scripts.sh/compileMarkdown --> <!DOCTYPE html> <html> <head> <title>Ashwin's Blog</title> <meta name='author' content='Ashwin Sundar'> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <link rel="stylesheet" href="../../styles/global.css" /> <link rel="stylesheet" href="../../styles/blog.css" /> </head>
<h1 id="learning-hard-things">Learning Hard Things</h1>
<p><a href="https://xkcd.com/1838/"><img alt = "The pile gets soaked with data and starts to get mushy over time, so it's technically recurrent." src = "https://imgs.xkcd.com/comics/machine_learning_2x.png"></a></p>
<p>I took a total of one computer science class in my undergraduate
degree. It was a CS class geared towards non-CS majors. The class
started at 10AM, which was about 2 hours before my brain started
functioning effectively. It was also 2 hours before I wanted to be
awake.</p>
<p>In that class, we were <a
href="https://www.math.ucla.edu/~akrieger/teaching/17f/pic10a/index.html">shown
many things</a>. Variables! Inputs and outputs! Roman numerals! Classes!
As a neuroscience major, I hadn’t the faintest clue what the point of
any of this was. Was programming supposed to be this esoteric, this
alien?</p>
<p>Computer science originated as an offshoot of mathematics. In my
younger days, I was good at math - I received the top score on the AP
tests for Calculus AB and BC in high school.</p>
<p>Yet this looked nothing like math, nothing like anything I had seen
before…</p>
<p><img title = "A veritable chrysalitic monster" alt = "A veritable chrysalitic monster" src = "/blog/assets/learn-hard-things/dali-sleep.JPG"></p>
<p>I fell asleep a lot in that class. Several times, I experienced some
form of <a href="https://en.wikipedia.org/wiki/Sleep_paralysis">sleep
paralysis</a> - unable to move, unable to breathe, my subconscious
listened to the lecturer drone on about objects and assignments and
operators.</p>
<p>Ultimately, I woke up and completed the course with some sort of
passing grade, along with a deep distaste for anything related to code.
I never took another class from the computer science department again.
It would be several years before I’d write another line of code.</p>
<h2 id="heuristics">Heuristics</h2>
<p>What I did not gain from that class was a set of reusable mental
models. In computer science and software engineering, one must rely on
mental models to represent complex details and abstractions. The
phenomenon one works with are often a combination of unobservable and
non-existent. Bits and bytes can’t be physically observed (unless one
works with an <a
href="https://en.wikipedia.org/wiki/Magnetic-core_memory">ancient
system</a>). Relationships between services are only as strong as the
code that defines them, which itself is merely a conglomeration of
symbols that are compiled down to bits and bytes. The good software
engineer MUST rely on abstractions to make any sense of the world.</p>
<p>With that established, let’s explore a few of my reusable mental
models.</p>
<h2 id="interfaces-are-like-legos">Interfaces are like Legos</h2>
<p>Legos interact with each other in a very well-defined manner. The
circular interlocking portions must be manufactured to a tolerance of <a
href="https://web.archive.org/web/20121209100137/http://cache.lego.com/upload/contentTemplating/AboutUsFactsAndFiguresContent/otherfiles/download98E142631E71927FDD52304C1C0F1685.pdf">10
micrometers</a> so that the bricks lock as expected, but can be removed
easily.</p>
<p>In a good software interface (e.g. an API), the parameters passed
around can be defined and characterized precisely, perhaps using input
validation and strong typing. The designer of an interface should know
and handle all the permutations of data in and data out. If a
surface-level function can’t handle negative values, then the designer
must know how the function will respond.</p>
<p>Back to Legos. Despite their extraordinarily tight specifications, in
the precisely-defined Lego universe, there is practically nothing that
can’t be built with Legos. Six 2x4 bricks fit together in <a
href="https://web.math.ku.dk/~eilers/lego.html">915,103,765 ways</a>. It
is unlikely any particular design decision by the designers enabled
this, but it is as if they built a Turing-complete construction
language.</p>
<p>Similarly, good interfaces shouldn’t unreasonably constrain the user
for the universe that the interface designer has created.</p>
<p>Finally, Lego interfaces behave like a “black box”. One can attach a
Lego to any interface of an existing Lego project without concern for
what color the bricks are, how many bricks are connected, or even the
types of all the other bricks involved. The interface is all that
matters.</p>
<h2 id="testing-is-an-n-dimensional-space">Testing is an n-dimensional
space</h2>
<p>When conducting experiments in school, one learns to modify only one
independent variable at a time. This is to make it easy to measure its
singular effect on the dependent variable. It is possible to test more
variables at once, but it is hard to visualize, more time-consuming, and
more difficult to plot nicely in a school report.</p>
<p>Using an idea from statistics called <a
href="https://asq.org/quality-resources/design-of-experiments">Design of
Experiments</a>, one can change two variables at once, creating a
3-dimensional space with a 3-dimensional functions.</p>
<p>What does this have to do with programming? A program is effectively
a transformation of inputs into outputs. It is easier to think about
this for an individual function:</p>
<pre><code>fun (a int, b int) -&gt; int { 
    ...stuff... 
}</code></pre>
<p>There are a few ways to test this function. The first is think really
hard about common inputs, and make sure the outputs are correct. The
next level is to figure out all the edge cases and test those as well.
At that point, that function would be considered reasonably well-tested.
But why is that? Why doesn’t 100% test coverage mean someone tested
<strong>every single possible input</strong>?</p>
<p>Because the style of testing has produced a series of points of data
through which a 2d curve can be traced through the 3d test space. The
input dimensions are a and b, and the output dimension is the result of
the function. As a result, one can interpolate any value within that
curve and know what the output is.</p>
<p>This example is clearly very simplified, but the concept can be
extrapolated to functions with more complicated inputs, as well as
entire programs.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The vast majority of programming involves taking things on faith. The
first level of faith many programmers encounter is faith in
documentation - that the vendor of a software accurately describes the
details of their abstraction. This is also the first place many
programmers’ trust is broken. At this point, one must make a decision -
dive into the abstraction layer, or abandon the tool and find a
different one whose documentation lies less?</p>
<p>Many times, we are forced to choose the former - dive into the
details. This is when it pays to have useful mental models, for the
deluge of information is about to become monumental. The HTML core spec
is</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> curl <span class="ex">-s</span> https://html.spec.whatwg.org/ <span class="kw">|</span> <span class="fu">sed</span> <span class="st">&#39;s/&lt;[^&gt;]*&gt;//g&#39;</span> <span class="kw">|</span> <span class="fu">wc</span> <span class="at">-w</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> 571215</span></code></pre></div>
<p>…that many words long. For a markup language! Fortunately, most HTML
tutorials don’t just say “read the spec”, but involve heavy use of
mental models and abstractions. Those models and abstractions are
usually right. Usually.</p>
<p><img title = "Pre-mystical-corpuscular" alt = "Pre-mystical-corpuscular" src = "/blog/assets/learn-hard-things/dali-temptation-st-anthony.JPG"></p>
<p>A good heuristic model is similar to a template for a software
project. It represents a solid starting point, is applicable for most
projects, and can be easily modified or extended. Developing and
utilizing these mental models reduces cognitive load and eases the
acquisition of new skills.</p>
<p>At the same time, one must avoid peering too closely at the
abstraction, for the spindly legs upon which it is mounted may
disintegrate and all that’s left is dust.</p>
</body> </html>
