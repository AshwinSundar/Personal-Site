<!DOCTYPE html> <html> <head> <title>Ashwin's Blog</title> <meta name='author' content='Ashwin Sundar'> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <link rel="stylesheet" href="../../styles/global.css" /> <link rel="stylesheet" href="../../styles/blog.css" /> </head> <body>
<h1 id="parallel-processing-in-rust">Parallel Processing in Rust</h1>
<p>Date: April 6th, 2022</p>
<p><a href="https://www.rust-lang.org/">Rust</a> is a systems
programming language that is quickly gaining traction at well-known
companies including Amazon, Discord, Dropbox, Meta, Alphabet, and
Microsoft. It is built for <a
href="https://www.rust-lang.org/">performance, reliability, and
productivity</a> and has been voted the most loved programming language
according to Stack Overflow’s <a
href="https://insights.stackoverflow.com/survey">Annual Developer
Survey</a> since 2016. Some large-scale commercial projects that have
been built using Rust include:</p>
<ul>
<li>Mozilla’s <a href="https://servo.org/">Servo</a> parallel browser
engine</li>
<li>Discord’s <a
href="https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f">Read
States</a> service</li>
<li>Polkadot’s <a
href="https://github.com/paritytech/polkadot">Substrate</a> blockchain
engine</li>
<li>Figma’s <a
href="https://www.figma.com/blog/rust-in-production-at-figma/">Multiplayer</a>
service</li>
</ul>
<p>All of these real-world use cases of Rust utilize and benefit from
concurrent and parallel processing, which can be daunting to implement
on a good day, and pretty terrifying when implemented <a
href="https://en.wikipedia.org/wiki/Therac-25">badly</a>. Rust helps
mitigate concurrency hazards by design, but it’s still up to the
programmer to construct their program logic thoughtfully so they can
take advantage of the power of concurrent and parallel processing.</p>
<p><strong>When should I use concurrent or parallel processing, instead
of serial processing?</strong></p>
<p>Most modern processors have multiple cores to work with, which means
you can use these cores to achieve significant performance gains:</p>
<ul>
<li>When you have a lot of independent computations to process, such as
a giant for-loop.</li>
<li>When some of your threads contain computations that are particularly
lengthy to calculate. It’s nice to run these on the “backburner” without
blocking your program from performing other computations.</li>
<li>When you have low <a
href="https://www.mathworks.com/help/parallel-computing/decide-when-to-use-parfor.html">parallel
overhead</a></li>
</ul>
<p><strong>How do I implement parallel processing in Rust?</strong> My
favorite way to learn new programming languages is by combining it with
my love for math and solving problems in <a
href="https://projecteuler.net/">Project Euler</a>. To demonstrate
parallelization in Rust, let’s solve a <a
href="https://projecteuler.net/problem=1">simple problem</a> that I
tweaked slightly so we can focus on the implementation of our
solution:</p>
<p><em>If we list all the natural numbers below 10 that are multiples of
3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the
sum of all the multiples of 3 or 5 below 1,000,000.</em></p>
<p><strong>Solution Methodology</strong> While the mathematically
elegant solution would be to use an <a
href="https://en.wikipedia.org/wiki/Arithmetic_progression">arithmetic
series</a>, let’s just focus on the simple solution, which is to figure
out if each number in the range is divisible by 3 or 5. If it is, let’s
add it to a running sum we’re keeping track of.</p>
<p><strong>Example 1 - No parallelization</strong></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> euler1_unpar(input<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i64</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> sum<span class="op">:</span> <span class="dt">i64</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">1</span><span class="op">..</span>input <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">%</span> <span class="dv">3</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> i <span class="op">%</span> <span class="dv">5</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>            sum <span class="op">+=</span> i <span class="kw">as</span> <span class="dt">i64</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    sum</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Code walkthrough:</strong> In this example, we accept an
<code>input</code>, and iterate on every number between
<code>1..input</code> to determine if it is divisible by 3 or 5 using
the modulo <code>%</code> operator. If it is, then add the value to a
running <code>sum</code> we’re keeping track of. At the end, return the
sum. In Rust, you can return a value by simply calling it without a
semicolon after the expression. Since Rust is a <a
href="https://en.wikipedia.org/wiki/Strong_and_weak_typing">strongly-typed</a>
language, we need to tell the compiler to add the original
<code>i32</code> input and convert the sum to an <code>i64</code>, so
that we have enough space to store the answer.</p>
<p>Let’s calculate a performance benchmark for this function so we can
compare it to our multithreaded optimization that we’ll write next. We
can calculate this benchmark with the <a
href="https://docs.rs/easybench/latest/easybench/">easybench</a> crate,
an importable package in Rust.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">easybench::</span><span class="op">{</span>bench<span class="op">};</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> input <span class="op">=</span> <span class="dv">1000000</span><span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;euler1_unpar: {}&quot;</span><span class="op">,</span> bench(<span class="op">||</span> euler1_unpar(input) ) )<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> euler1_unpar<span class="op">:</span> <span class="dv">14.4</span>29298ms (R²<span class="op">=</span><span class="dv">0.999</span><span class="op">,</span> <span class="dv">70</span> iterations <span class="kw">in</span> <span class="dv">21</span> samples)</span></code></pre></div>
<p>Our unparallelized function takes about <code>14.4</code>
milliseconds to execute.</p>
<p><strong>Example 2 - Parallelized (2 threads)</strong></p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> euler1_par(input<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i64</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::</span>thread<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> handle1 <span class="op">=</span> <span class="pp">thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> thread1_sum<span class="op">:</span> <span class="dt">i64</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">1</span><span class="op">..</span>input <span class="op">/</span> <span class="dv">2</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">%</span> <span class="dv">3</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> i <span class="op">%</span> <span class="dv">5</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>                thread1_sum <span class="op">+=</span> i <span class="kw">as</span> <span class="dt">i64</span><span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        thread1_sum</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> handle2 <span class="op">=</span> <span class="pp">thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> thread2_sum<span class="op">:</span> <span class="dt">i64</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> (input <span class="op">/</span> <span class="dv">2</span>)<span class="op">..</span>input <span class="op">{</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">%</span> <span class="dv">3</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> i <span class="op">%</span> <span class="dv">5</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>                thread2_sum <span class="op">+=</span> i <span class="kw">as</span> <span class="dt">i64</span><span class="op">;</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        thread2_sum</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    handle1<span class="op">.</span>join()<span class="op">.</span>unwrap() <span class="op">+</span> handle2<span class="op">.</span>join()<span class="op">.</span>unwrap()</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Code walkthrough:</strong> Here, we use the
<code>thread</code> module so that we can take advantage of the native
multithreading available in Rust. A new thread is created by calling
<code>thread::spawn</code>, into which a <code>closure</code> is passed.
<a
href="https://doc.rust-lang.org/book/ch13-01-closures.html">Closures</a>
are anonymous functions that allow you to access environment variables,
such as the <code>input</code> variable. This closure does the same
mathematical computation as <code>euler1_unpar</code>, except we only
process one half of the total range in the thread. The other half is
saved for the second thread. We also need to <code>move</code> a copy of
the input into the closure’s scope so that the thread can take ownership
of the data and use it. Writing code like this can seem tedious and
time-consuming, but is required by Rust to help reduce the risk of <a
href="https://doc.rust-lang.org/book/ch16-00-concurrency.html">concurrency
errors</a>.</p>
<p><code>thread::spawn</code> returns a <code>JoinHandle</code> type,
which contains some convenience methods that allow us to take back
control over the threads and handle their results. In this case,
<code>JoinHandle::join()</code> halts execution of the function until
our threads have finished their calculations. <code>.unwrap()</code>
exposes the answers we’ve calculated in each thread, and then finally we
sum those answers up.</p>
<p>Let’s see how long this function takes to run:</p>
<pre><code>use easybench::{bench};
let input = 1000000;
println!(&quot;{}&quot;, euler1_par(input));

&gt; euler1_par:  7.345441ms (R²=0.998, 133 iterations in 27 samples)</code></pre>
<p>The parallelized function takes about <code>7.3</code> milliseconds
to execute.</p>
<p><strong>Conclusion</strong> The parallelized code runs almost twice
as fast as our unparallelized code, and we seem to only lose a little
performance due to the overhead of setting up the threads. Nice!</p>
<p>This example demonstrates a way to get started with parallel
processing in Rust. You often need to design your program with
parallelization in mind from the get-go, as you are forced to think
about the flow of your code and determine what pieces of the code take
the longest to run and would benefit from parallelization.</p>
<p><em>This article was originally written for the <a
href="https://engineering.deptagency.com/parallel-processing-in-rust">engineering
blog</a> at DEPT®, a technology consultancy</em></p>
</body> </html>
