<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Ashwin Sundar</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Parallel Processing in Rust Date: April 6th, 2022
Rust is a systems programming language that is quickly gaining traction at well-known companies including Amazon, Discord, Dropbox, Meta, Alphabet, and Microsoft. It is built for performance, reliability, and productivity and has been voted the most loved programming language according to Stack Overflow&rsquo;s Annual Developer Survey since 2016. Some large-scale commercial projects that have been built using Rust include:
Mozilla&rsquo;s Servo parallel browser engine Discord&rsquo;s Read States service Polkadot&rsquo;s Substrate blockchain engine Figma&rsquo;s Multiplayer service All of these real-world use cases of Rust utilize and benefit from concurrent and parallel processing, which can be daunting to implement on a good day, and pretty terrifying when implemented badly.">
    <meta name="generator" content="Hugo 0.123.0">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/blog/parallel-processing-rust/">
    

    <meta property="og:title" content="" />
<meta property="og:description" content="Parallel Processing in Rust Date: April 6th, 2022
Rust is a systems programming language that is quickly gaining traction at well-known companies including Amazon, Discord, Dropbox, Meta, Alphabet, and Microsoft. It is built for performance, reliability, and productivity and has been voted the most loved programming language according to Stack Overflow&rsquo;s Annual Developer Survey since 2016. Some large-scale commercial projects that have been built using Rust include:
Mozilla&rsquo;s Servo parallel browser engine Discord&rsquo;s Read States service Polkadot&rsquo;s Substrate blockchain engine Figma&rsquo;s Multiplayer service All of these real-world use cases of Rust utilize and benefit from concurrent and parallel processing, which can be daunting to implement on a good day, and pretty terrifying when implemented badly." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/blog/parallel-processing-rust/" /><meta property="article:section" content="blog" />



<meta itemprop="name" content="">
<meta itemprop="description" content="Parallel Processing in Rust Date: April 6th, 2022
Rust is a systems programming language that is quickly gaining traction at well-known companies including Amazon, Discord, Dropbox, Meta, Alphabet, and Microsoft. It is built for performance, reliability, and productivity and has been voted the most loved programming language according to Stack Overflow&rsquo;s Annual Developer Survey since 2016. Some large-scale commercial projects that have been built using Rust include:
Mozilla&rsquo;s Servo parallel browser engine Discord&rsquo;s Read States service Polkadot&rsquo;s Substrate blockchain engine Figma&rsquo;s Multiplayer service All of these real-world use cases of Rust utilize and benefit from concurrent and parallel processing, which can be daunting to implement on a good day, and pretty terrifying when implemented badly.">

<meta itemprop="wordCount" content="1019">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/><meta name="twitter:title" content=""/>
<meta name="twitter:description" content="Parallel Processing in Rust Date: April 6th, 2022
Rust is a systems programming language that is quickly gaining traction at well-known companies including Amazon, Discord, Dropbox, Meta, Alphabet, and Microsoft. It is built for performance, reliability, and productivity and has been voted the most loved programming language according to Stack Overflow&rsquo;s Annual Developer Survey since 2016. Some large-scale commercial projects that have been built using Rust include:
Mozilla&rsquo;s Servo parallel browser engine Discord&rsquo;s Read States service Polkadot&rsquo;s Substrate blockchain engine Figma&rsquo;s Multiplayer service All of these real-world use cases of Rust utilize and benefit from concurrent and parallel processing, which can be daunting to implement on a good day, and pretty terrifying when implemented badly."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Ashwin Sundar
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Blogs
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1"></h1>
      
      
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id="parallel-processing-in-rust">Parallel Processing in Rust</h1>
<p>Date: April 6th, 2022</p>
<p><a href="https://www.rust-lang.org/">Rust</a> is a systems programming language that is quickly gaining traction at well-known companies including Amazon, Discord, Dropbox, Meta, Alphabet, and Microsoft. It is built for <a href="https://www.rust-lang.org/">performance, reliability, and productivity</a> and has been voted the most loved programming language according to Stack Overflow&rsquo;s <a href="https://insights.stackoverflow.com/survey">Annual Developer Survey</a> since 2016. Some large-scale commercial projects that have been built using Rust include:</p>
<ul>
<li>Mozilla&rsquo;s <a href="https://servo.org/">Servo</a> parallel browser engine</li>
<li>Discord&rsquo;s <a href="https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f">Read States</a> service</li>
<li>Polkadot&rsquo;s <a href="https://github.com/paritytech/polkadot">Substrate</a> blockchain engine</li>
<li>Figma&rsquo;s <a href="https://www.figma.com/blog/rust-in-production-at-figma/">Multiplayer</a> service</li>
</ul>
<p>All of these real-world use cases of Rust utilize and benefit from concurrent and parallel processing, which can be daunting to implement on a good day, and pretty terrifying when implemented <a href="https://en.wikipedia.org/wiki/Therac-25">badly</a>. Rust helps mitigate concurrency hazards by design, but it&rsquo;s still up to the programmer to construct their program logic thoughtfully so they can take advantage of the power of concurrent and parallel processing.</p>
<p><strong>When should I use concurrent or parallel processing, instead of serial processing?</strong></p>
<p>Most modern processors have multiple cores to work with, which means you can use these cores to achieve significant performance gains:</p>
<ul>
<li>When you have a lot of independent computations to process, such as a giant for-loop.</li>
<li>When some of your threads contain computations that are particularly lengthy to calculate. It&rsquo;s nice to run these on the &ldquo;backburner&rdquo; without blocking your program from performing other computations.</li>
<li>When you have low <a href="https://www.mathworks.com/help/parallel-computing/decide-when-to-use-parfor.html">parallel overhead</a></li>
</ul>
<p><strong>How do I implement parallel processing in Rust?</strong>
My favorite way to learn new programming languages is by combining it with my love for math and solving problems in <a href="https://projecteuler.net/">Project Euler</a>. To demonstrate parallelization in Rust, let&rsquo;s solve a <a href="https://projecteuler.net/problem=1">simple problem</a> that I tweaked slightly so we can focus on the implementation of our solution:</p>
<p><em>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1,000,000.</em></p>
<p><strong>Solution Methodology</strong>
While the mathematically elegant solution would be to use an <a href="https://en.wikipedia.org/wiki/Arithmetic_progression">arithmetic series</a>, let&rsquo;s just focus on the simple solution, which is to figure out if each number in the range is divisible by 3 or 5. If it is, let&rsquo;s add it to a running sum we&rsquo;re keeping track of.</p>
<p><strong>Example 1 - No parallelization</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">euler1_unpar</span>(input: <span style="color:#66d9ef">i32</span>) -&gt; <span style="color:#66d9ef">i64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sum: <span style="color:#66d9ef">i64</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>input {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            sum <span style="color:#f92672">+=</span> i <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i64</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    sum
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Code walkthrough:</strong> In this example, we accept an <code>input</code>, and iterate on every number between <code>1..input</code> to determine if it is divisible by 3 or 5 using the modulo <code>%</code> operator. If it is, then add the value to a running <code>sum</code> we&rsquo;re keeping track of. At the end, return the sum. In Rust, you can return a value by simply calling it without a semicolon after the expression. Since Rust is a <a href="https://en.wikipedia.org/wiki/Strong_and_weak_typing">strongly-typed</a> language, we need to tell the compiler to add the original <code>i32</code> input and convert the sum to an <code>i64</code>, so that we have enough space to store the answer.</p>
<p>Let&rsquo;s calculate a performance benchmark for this function so we can compare it to our multithreaded optimization that we&rsquo;ll write next. We can calculate this benchmark with the <a href="https://docs.rs/easybench/latest/easybench/">easybench</a> crate, an importable package in Rust.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> easybench::{bench};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> input <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000000</span>;
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;euler1_unpar: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, bench(<span style="color:#f92672">||</span> euler1_unpar(input) ) );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;</span> euler1_unpar: <span style="color:#ae81ff">14.429298</span>ms (R<span style="color:#960050;background-color:#1e0010">²</span><span style="color:#f92672">=</span><span style="color:#ae81ff">0.999</span>, <span style="color:#ae81ff">70</span> iterations <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">21</span> samples)
</span></span></code></pre></div><p>Our unparallelized function takes about <code>14.4</code> milliseconds to execute.</p>
<p><strong>Example 2 - Parallelized (2 threads)</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">euler1_par</span>(input: <span style="color:#66d9ef">i32</span>) -&gt; <span style="color:#66d9ef">i64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">use</span> std::thread;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> handle1 <span style="color:#f92672">=</span> thread::spawn(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> thread1_sum: <span style="color:#66d9ef">i64</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>input <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>                thread1_sum <span style="color:#f92672">+=</span> i <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i64</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        thread1_sum
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> handle2 <span style="color:#f92672">=</span> thread::spawn(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> thread2_sum: <span style="color:#66d9ef">i64</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> (input <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>)<span style="color:#f92672">..</span>input {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>                thread2_sum <span style="color:#f92672">+=</span> i <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i64</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        thread2_sum
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    handle1.join().unwrap() <span style="color:#f92672">+</span> handle2.join().unwrap()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Code walkthrough:</strong> Here, we use the <code>thread</code> module so that we can take advantage of the native multithreading available in Rust. A new thread is created by calling <code>thread::spawn</code>, into which a <code>closure</code> is passed. <a href="https://doc.rust-lang.org/book/ch13-01-closures.html">Closures</a> are anonymous functions that allow you to access environment variables, such as the <code>input</code> variable. This closure does the same mathematical computation as <code>euler1_unpar</code>, except we only process one half of the total range in the thread. The other half is saved for the second thread. We also need to <code>move</code> a copy of the input into the closure&rsquo;s scope so that the thread can take ownership of the data and use it. Writing code like this can seem tedious and time-consuming, but is required by Rust to help reduce the risk of <a href="https://doc.rust-lang.org/book/ch16-00-concurrency.html">concurrency errors</a>.</p>
<p><code>thread::spawn</code> returns a <code>JoinHandle</code> type, which contains some convenience methods that allow us to take back control over the threads and handle their results. In this case, <code>JoinHandle::join()</code> halts execution of the function until our threads have finished their calculations. <code>.unwrap()</code> exposes the answers we&rsquo;ve calculated in each thread, and then finally we sum those answers up.</p>
<p>Let&rsquo;s see how long this function takes to run:</p>
<pre tabindex="0"><code>use easybench::{bench};
let input = 1000000;
println!(&#34;{}&#34;, euler1_par(input));

&gt; euler1_par:  7.345441ms (R²=0.998, 133 iterations in 27 samples)
</code></pre><p>The parallelized function takes about <code>7.3</code> milliseconds to execute.</p>
<p><strong>Conclusion</strong>
The parallelized code runs almost twice as fast as our unparallelized code, and we seem to only lose a little performance due to the overhead of setting up the threads. Nice!</p>
<p>This example demonstrates a way to get started with parallel processing in Rust. You often need to design your program with parallelization in mind from the get-go, as you are forced to think about the flow of your code and determine what pieces of the code take the longest to run and would benefit from parallelization.</p>
<p><em>This article was originally written for the <a href="https://engineering.deptagency.com/parallel-processing-in-rust">engineering blog</a> at DEPT®, a technology consultancy</em></p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  Ashwin Sundar 2024 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
