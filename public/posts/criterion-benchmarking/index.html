<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>%!s(&lt;nil&gt;) | Ashwin Sundar</title>

    <link rel="stylesheet" href="/css/o.posts.tw.css">



</head>

<body class="p-6 md:p-12 bg-paper">
  <header class="pb-8">
    <h1 class="text-2xl text-gray-400">Ashwin Sundar</h2>


  </header>
  <main>
    
  <h1>Benchmarking Rust code with Criterion.rs</h1>

  
  
  <time datetime="2022-06-14T00:00:00&#43;00:00">June 14, 2022</time>

  <h1 id="benchmarking-rust-code-using-criterionrs">Benchmarking Rust code using Criterion.rs</h1>
<h2 id="introduction">Introduction</h2>
<p>Benchmarking is a method of systematically assessing a program for performance. This process is a valuable component of regression testing because it helps you compare changes and improvements to your code. The systems programming language Rust offers many statistically rigorous analysis techniques, such as the <a href="https://docs.rs/criterion/latest/criterion/"><em>Criterion</em></a> crate, which is a popular tool used for benchmarking in Rust. In this article, we&rsquo;ll go into more detail on how to use <em>Criterion</em> to compare various Rust functions to solve a problem from <a href="https://projecteuler.net/">Project Euler</a>.</p>
<h2 id="about-criterion">About Criterion</h2>
<p><em>Criterion</em> is a benchmarking crate that specializes in statistically rigorous analysis techniques, as well as generating useful and attractive charts using <code>gnuplot</code>. The <a href="https://github.com/bheisler/criterion.rs#goals">primary goals</a> of <em>Criterion</em> are to measure the performance of code, prevent performance regressions, and accurately measure optimizations.</p>
<h1 id="example">Example</h1>
<p>To understand how to use <em>Criterion</em> for benchmarking, let&rsquo;s re-use an example from a previous article where we learned how to implement <a href="https://engineering.deptagency.com/parallel-processing-in-rust">parallel processing in Rust</a>. In that article we explored how to parallelize a commutative loop. This time, let&rsquo;s compare the parallelized function to a function that solves the problem with an arithmetic series. The problem:</p>
<p><em>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000000.</em></p>
<h2 id="setup-steps">Setup steps</h2>
<p>The code used in this article can be found at <a href="https://github.com/AshwinSundar/Criterion-Benchmarking">https://github.com/AshwinSundar/Criterion-Benchmarking</a>. Let&rsquo;s start by creating a new Rust project in an empty folder called <code>Criterion_Benchmarking</code>. <code>cd</code> into the folder and type <code>cargo init</code>.</p>
<p><strong>Terminal</strong></p>
<pre tabindex="0"><code>‚ùØ cargo init
     Created binary (application) package
</code></pre><h2 id="1-add-criterion-to-dev-dependencies">1. Add Criterion to dev-dependencies</h2>
<p><strong>$PROJECT/Cargo.toml</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>[<span style="color:#960050;background-color:#1e0010">dev-dependencies</span>]
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">criterion</span> <span style="color:#960050;background-color:#1e0010">=</span> {<span style="color:#960050;background-color:#1e0010">version</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#f92672">&#34;0.3&#34;</span>, <span style="color:#960050;background-color:#1e0010">features</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#960050;background-color:#1e0010">[</span><span style="color:#f92672">&#34;html_reports&#34;</span><span style="color:#960050;background-color:#1e0010">]</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[[<span style="color:#960050;background-color:#1e0010">bench</span>]]
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">name</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#e6db74">&#34;euler1_benchmark&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">harness</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#66d9ef">false</span>
</span></span></code></pre></div><p>First, navigate to the Rust manifest file <code>Cargo.toml</code> and create a <code>dev-dependencies</code> section. Adding <em>Criterion</em> to this section ensures that the benchmarking crate is only included during testing, and not in production builds. Let&rsquo;s also disable the default benchmarking harness <a href="https://github.com/rust-lang/libtest"><code>libtest</code></a> by setting <code>harness=false</code>, that way the compiler invokes the <em>Criterion</em> benchmarking harness instead.</p>
<h2 id="2-create-benchmark-file">2. Create benchmark file</h2>
<p><strong>$PROJECT/benches/euler1_benchmark.rs</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> criterion::{black_box, criterion_group, criterion_main, Criterion};
</span></span><span style="display:flex;"><span><span style="color:#75715e">// use lib::euler1; // function to profile
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">criterion_benchmark</span>(c: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Criterion) {
</span></span><span style="display:flex;"><span><span style="color:#75715e">// c.bench_function(&#34;euler1&#34;, |b| b.iter(|| euler1(black_box(input))));
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>criterion_group!(benches, criterion_benchmark);
</span></span><span style="display:flex;"><span>criterion_main!(benches);
</span></span></code></pre></div><p>Next, create a benchmark file at <code>$PROJECT/benches/euler1_benchmark.rs</code>. This file will import our function, run a benchmark, and then output the results to the console using a macro. We&rsquo;ll leave a couple placeholders for now and revisit this file once we&rsquo;ve built the functions to benchmark.</p>
<h2 id="3-create-library-file">3. Create library file</h2>
<p><strong>$PROJECT/src/lib.rs</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[inline]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">euler1_simple</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// For-loop solution
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[inline]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">euler1_par</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Parallelized solution
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[inline]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">euler1_series</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Arithmetic series solution
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Finally, due to <a href="https://bheisler.github.io/criterion.rs/book/user_guide/known_limitations.html">implementation constraints</a> within <em>Criterion</em>, we need to create a library file to host our functions at <code>src/lib.rs</code> and declare our functions as <code>public</code>, so that we can import the functions into <code>euler1_benchmark.rs</code>. The <a href="https://nnethercote.github.io/perf-book/inlining.html">#[inline]</a> attribute above the function helps reduce execution time slightly and improves the accuracy of the benchmarking process.</p>
<p>Now that we&rsquo;ve written some boilerplate code for the benchmark, let&rsquo;s return to the actual problem and compare a few possible solutions.</p>
<h1 id="solutions">Solutions</h1>
<p>If you&rsquo;re interested in the details of each solution, read this section. Otherwise, you can skip to the <a href="#creating-benchmarks">Creating Benchmarks</a> section. Just know that the three solutions are, in order of least to most efficient, a simple for-loop, a parallelized for-loop, and an arithmetic series.</p>
<p>To reiterate the problem:</p>
<p><em>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000000.</em></p>
<h2 id="solution-1-for-loop">Solution 1: For-loop</h2>
<p><strong>$PROJECT/src/lib.rs</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[inline]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">euler1_simple</span>(input: <span style="color:#66d9ef">i64</span>) -&gt; <span style="color:#66d9ef">i64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sum: <span style="color:#66d9ef">i64</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>input {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            sum <span style="color:#f92672">+=</span> i <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i64</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    sum
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>A simple brute-force solution is to iterate on every number in the range and determine if it&rsquo;s divisible by either 3 or 5. This solution will give us a good baseline to compare the other solutions to.</p>
<h2 id="solution-2-parallelized-for-loop">Solution 2: Parallelized for-loop</h2>
<p><strong>$PROJECT/src/lib.rs</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[inline]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">euler1_par</span>(input: <span style="color:#66d9ef">i64</span>) -&gt; <span style="color:#66d9ef">i64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">use</span> std::thread;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> threads <span style="color:#f92672">=</span> thread::available_parallelism().unwrap().get() <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> input <span style="color:#f92672">=</span> input <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> handles: Vec<span style="color:#f92672">&lt;</span>JoinHandle<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i64</span><span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">=</span> vec![];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> t <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..=</span>(threads <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i32</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> t <span style="color:#f92672">=</span> t <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> upper_bound <span style="color:#f92672">=</span> (input <span style="color:#f92672">*</span> (t <span style="color:#f92672">/</span> threads)) <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i32</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> lower_bound <span style="color:#f92672">=</span> (input <span style="color:#f92672">*</span> (t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#66d9ef">f64</span>) <span style="color:#f92672">/</span> threads) <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i32</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        handles.push(thread::spawn(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sum: <span style="color:#66d9ef">i64</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> lower_bound<span style="color:#f92672">..</span>upper_bound {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>                    sum <span style="color:#f92672">+=</span> i <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i64</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            sum
</span></span><span style="display:flex;"><span>        }));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> h <span style="color:#66d9ef">in</span> handles {
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">+=</span> h.join().unwrap();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    sum
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In a <a href="https://engineering.deptagency.com/parallel-processing-in-rust">previous article</a>, we started to explore parallelization using <code>std::thread</code>, a library for distributing program processing to OS threads. We stopped at two threads in that article, so in this example I&rsquo;ve expanded the function to accomodate all available system threads.</p>
<p>Let&rsquo;s step through this code piece by piece.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">use</span> std::thread;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> threads <span style="color:#f92672">=</span> thread::available_parallelism().unwrap().get() <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> input <span style="color:#f92672">=</span> input <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> handles: Vec<span style="color:#f92672">&lt;</span>JoinHandle<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i64</span><span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">=</span> vec![];
</span></span></code></pre></div><p>First, we need to import the native parallelism module <a href="https://doc.rust-lang.org/std/thread/"><code>std::thread</code></a> and determine how many OS threads are available on the system using <a href="https://doc.rust-lang.org/std/thread/fn.available_parallelism.html"><code>std::thread::available_parallelism()</code></a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> t <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..=</span>(threads <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i32</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> t <span style="color:#f92672">=</span> t <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> upper_bound <span style="color:#f92672">=</span> (input <span style="color:#f92672">*</span> (t <span style="color:#f92672">/</span> threads)) <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i32</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> lower_bound <span style="color:#f92672">=</span> (input <span style="color:#f92672">*</span> (t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#66d9ef">f64</span>) <span style="color:#f92672">/</span> threads) <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i32</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        handles.push(thread::spawn(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sum: <span style="color:#66d9ef">i64</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> lower_bound<span style="color:#f92672">..</span>upper_bound {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>                    sum <span style="color:#f92672">+=</span> i <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i64</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            sum
</span></span><span style="display:flex;"><span>        }));
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Next, we set up all our threads using <code>thread::spawn</code>, and pass in a <a href="https://doc.rust-lang.org/rust-by-example/fn/closures.html">closure</a> containing the same calculation as <code>euler1_simple</code>. The trick to this code is that the range of elements being iterated upon must be split up and processed. The range for each handle to process is computed in <code>upper_bound</code> and <code>lower_bound</code>. As each handle completes, its output is pushed into a vector of <code>handles</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> h <span style="color:#66d9ef">in</span> handles {
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">+=</span> h.join().unwrap();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    sum
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Since the calculations in each subset of the range are independent of each other, the final outputs are commutative and can be summed up with <code>sum += h.join().unwrap();</code></p>
<h2 id="solution-3-arithmetic-series">Solution 3: Arithmetic Series</h2>
<p>The sum of the multiples of 3 or 5 is a composite arithmetic series. An <a href="https://mathworld.wolfram.com/ArithmeticSeries.html"><em>arithmetic series</em></a> is the sum of a sequence of numbers where each subsequent term can be calculated by adding a constant $d$ to the last term. For example, for the sequence $2,5,8,&hellip;a_n$, $a_1=2$, $d=3$, and can be represented as:</p>
<p>$a_1, a_2 = a_1 + d, a_3 = a_1 + 2d,&hellip;a_{n-1} = a_1 + (n-2)d, a_n = a_1 + (n - 1)d$</p>
<p>Naturally, it follows that the sum of this sequence is:</p>
<p>$S_n = a_1 + (a_1 + d) + (a_1 + 2d) + &hellip; + (a_1 + (n-2)d) + (a_1 + (n - 1)d)$</p>
<p>Cleverly, the series formula is derived by rewriting this sum in another way, with respect to the last value in the sequence $a_n$:</p>
<p>$S_n = (a_n - (n-1)d) + (a_n - (n-2)d) + &hellip; + (a_n - 2d) + (a_n - d) + a_n$</p>
<p>Adding these two formulas together causes all terms involving $d$ to cancel out, and we&rsquo;re left with $2S_n = n(a_1 + a_n)$, which simplifies to $S_n = \frac{n}{2}(a_1 + a_n)$.</p>
<p>In the special case where each number in the sequence is a multiple of the first (e.g. 3, 6, 9, 12), then $a_n = n * a_1$, and the formula can be written as $S_n = \frac{n}{2}(a_1 + n * a_1)$, which simplifies to:</p>
<p>$S_n = \frac{n * a_1}{2}(1 + n)$</p>
<p>This is the formula we&rsquo;ll implement in the code below.</p>
<p><strong>$PROJECT/src/lib.rs</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[inline]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">euler1_series</span>(input: <span style="color:#66d9ef">i64</span>) -&gt; <span style="color:#66d9ef">i64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> val <span style="color:#f92672">=</span> input <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> n_3 <span style="color:#f92672">=</span> val <span style="color:#f92672">/</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> n_5 <span style="color:#f92672">=</span> val <span style="color:#f92672">/</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> n_15 <span style="color:#f92672">=</span> val <span style="color:#f92672">/</span> <span style="color:#ae81ff">15</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> sum_three <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> n_3 <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> n_3) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> sum_five <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">*</span> n_5 <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> n_5) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> sum_fifteen <span style="color:#f92672">=</span> <span style="color:#ae81ff">15</span> <span style="color:#f92672">*</span> n_15 <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> n_15) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum_three <span style="color:#f92672">+</span> sum_five <span style="color:#f92672">-</span> sum_fifteen
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Recall that the original problem asks to calculate the sum of the multiples <em>below</em> <code>input</code>, which is why we first declare <code>let val = input - 1;</code>. This was implicitly handled in the <code>for</code> loops in the previous two solutions, because the upper bound of the range iterator is <a href="https://doc.rust-lang.org/std/ops/struct.Range.html#fields">exclusive</a>. Next, we find the number of terms <code>n</code> by using the fact that the integer type in Rust implements division in such a way that the result is floored, so that the answers remains an integer. Finally, we implement the series formula for multiples of 3 and multiples of 5, add the results, and subtract the sum of the multiples of 15, because it is the least common multiple of 3 and 5.</p>
<h1 id="creating-benchmarks">Creating Benchmarks</h1>
<p>Replace the code in <code>benches/euler1_benchmark.rs</code> with:</p>
<p><strong>$PROJECT/benches/euler1_benchmark.rs</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> criterion::{black_box, criterion_group, criterion_main, Criterion};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> criterion_benchmarking::{euler1_par, euler1_series, euler1_simple};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">criterion_benchmark</span>(c: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Criterion) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> input <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000000</span>;
</span></span><span style="display:flex;"><span>    c.bench_function(<span style="color:#e6db74">&#34;simple&#34;</span>, <span style="color:#f92672">|</span>b<span style="color:#f92672">|</span> b.iter(<span style="color:#f92672">||</span> euler1_simple(black_box(input))));
</span></span><span style="display:flex;"><span>    c.bench_function(<span style="color:#e6db74">&#34;parallel&#34;</span>, <span style="color:#f92672">|</span>b<span style="color:#f92672">|</span> b.iter(<span style="color:#f92672">||</span> euler1_par(black_box(input))));
</span></span><span style="display:flex;"><span>    c.bench_function(<span style="color:#e6db74">&#34;series&#34;</span>, <span style="color:#f92672">|</span>b<span style="color:#f92672">|</span> b.iter(<span style="color:#f92672">||</span> euler1_series(black_box(input))));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>criterion_group!(benches, criterion_benchmark);
</span></span><span style="display:flex;"><span>criterion_main!(benches);
</span></span></code></pre></div><p>In the above code, <code>.bench_function</code> defines a benchmark with a <em>name</em> and a <em>closure</em>. The name must be unique among the benchmarks in the project. The closure accepts one argument, <a href="http://bheisler.github.io/criterion.rs/criterion/struct.Bencher.html"><code>Bencher</code></a>, which is a <code>Timer</code> struct used to iterate a benchmarked function and measure the runtime. <a href="https://docs.rs/criterion/0.2.6/criterion/fn.black_box.html"><code>black_box</code></a> is a function that prevents the Rust compiler from pre-optimizing the function prior to runtime, which can result in a quicker benchmark time than real-world use cases. <a href="https://docs.rs/criterion/latest/criterion/macro.criterion_group.html"><code>criterion_group!(...)</code></a> and <a href="https://docs.rs/criterion/latest/criterion/macro.criterion_main.html"><code>criterion_main!(...)</code></a> are <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">macros</a>, which together generate a benchmark group and a <code>main</code> function that executes the benchmarks. This is also why the benchmark is conducted in a separate file from <code>main.rs</code>, which already defines its own <code>main()</code> function.</p>
<p>To run the benchmark, type <code>cargo bench</code> in the terminal. After several seconds, you should see an output like this:</p>
<pre tabindex="0"><code>Benchmarking simple: Warming up for 3.0000 s
simple                  time:   [1.1540 ms 1.1564 ms 1.1589 ms]
Found 2 outliers among 100 measurements (2.00%)
  1 (1.00%) high mild
  1 (1.00%) high severe
Benchmarking parallel: Warming up for 3.0000 s
parallel                time:   [224.43 us 227.90 us 231.96 us]
Found 10 outliers among 100 measurements (10.00%)
  5 (5.00%) high mild
  5 (5.00%) high severe
Benchmarking series: Warming up for 3.0000 s
series                  time:   [2.4586 ns 2.4645 ns 2.4708 ns]
Found 1 outliers among 100 measurements (1.00%)
  1 (1.00%) high mild
</code></pre><p>The <code>time</code> array represents a 95% confidence interval, where the mean execution time is the second value in the array. Outliers are determined using a modified version of <a href="https://bheisler.github.io/criterion.rs/book/analysis.html#outlier-classification">Tukey&rsquo;s method</a>.</p>
<p>A more consumable version of this information is automatically generated and is available in <code>$PROJECT/target/criterion/{benchmark-name}/report/index.html</code>.</p>
<h1 id="under-the-hood">Under the Hood</h1>
<p>Before we compare the charts for each function, let&rsquo;s briefly explore what <em>Criterion</em> is doing behind the scenes. The first step of the process is warm-up, which involves running the function repeatedly for a short period of time in order to allow the CPU and OS caches to adapt to the new load.</p>
<p>Second, after the warm-up process is complete, measurements are taken by repeatedly running the function under examination.</p>
<p>Third, the samples are analyzed and the results are compiled into useful statistics for the user. This involves custom outlier analysis and linear regression analysis.</p>
<p>Finally, the current run is compared to the previous run to determine if any statistically significant change has occurred, which is reported to the user.</p>
<p>More details about the analysis process can be found at <a href="https://bheisler.github.io/criterion.rs/book/analysis.html">https://bheisler.github.io/criterion.rs/book/analysis.html</a>.</p>
<h2 id="comparing-functions">Comparing Functions</h2>
<p>Let&rsquo;s look at the reports for each function.</p>
<p><em>euler1_simple</em></p>
<!-- raw HTML omitted -->
<p><em>euler1_par</em></p>
<!-- raw HTML omitted -->
<p><em>euler1_series</em></p>
<!-- raw HTML omitted -->
<p>The top left plot in each report is a <a href="https://en.wikipedia.org/wiki/Probability_density_function">probability density function</a>, which depicts the average time per iteration of the function. The blue bar represents the overall mean. The shaded region represents the probability that execution of this function will take a particular amount of time, while integrating the area between two times will provide the probability that the function will execute within that range of time. The top right plot is the linear regression for the function. Each iteration is plotted in order and the y-axis represents cumulative time to execute all iterations up to that point. The slope of this line is given under <strong>Additional Statistics</strong>.</p>
<p><em>R</em><!-- raw HTML omitted --><em>2</em><!-- raw HTML omitted --> and <em>standard deviation</em> are also useful statistics to look at. In the context of the benchmarking process, a low <em>R</em><!-- raw HTML omitted --><em>2</em><!-- raw HTML omitted --> means in statistical terms that a significant amount of the variability between each iteration isn&rsquo;t attributable to differences in the function itself. However, we know that every time the function executes, the exact same code is executed, so what does that sentence actually mean? In this context, it means that the benchmarking process we&rsquo;ve written is not behaving the same way in each iteration.</p>
<p>For <em>euler1_par</em>, this is in fact the case. I think the reason that this function in particular has a lot of variability is because it is implementing a parallelization routine, which relies on the processor to queue up tasks. How each <code>handle</code> is queued may vary based on the instantaneous load when each iteration is executed.</p>
<p>The <em>standard deviation</em> tells you (for a roughly normally distributed curve) that 95% of the samples landed between $¬µ ¬± 2œÉ$ (mean time ¬± 2 standard deviations).</p>
<h2 id="advanced-features">Advanced Features</h2>
<p><em>Criterion</em> has a lot of advanced features for the statistically inclined, two of which we&rsquo;ll explore in more detail: <code>benchmark_group</code> and <code>bench_with_input</code>.</p>
<h3 id="criterioncriterionbenchmark_group">criterion::Criterion::benchmark_group</h3>
<p>It&rsquo;s apparent that the parallelized function($¬µ=227.90$ us) is nearly 1 order of magnitude faster than the simple($¬µ=1.1564$ ms) function, while the series function($¬µ=2.4645$ ns) is nearly 3 orders of magnitude faster. We can generate a combined report that summarizes the performance of all three functions by associating them with each other using <code>benchmark_group</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> criterion::{black_box, criterion_group, criterion_main, Criterion};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> criterion_benchmarking::{euler1_par, euler1_series, euler1_simple};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">criterion_benchmark</span>(c: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Criterion) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> input <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000000</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> group <span style="color:#f92672">=</span> c.benchmark_group(<span style="color:#e6db74">&#34;Euler 1&#34;</span>);
</span></span><span style="display:flex;"><span>    group.bench_function( <span style="color:#e6db74">&#34;simple - test 1&#34;</span>, <span style="color:#f92672">|</span>b<span style="color:#f92672">|</span> b.iter(<span style="color:#f92672">||</span> euler1_simple(black_box(input))) );
</span></span><span style="display:flex;"><span>    group.bench_function( <span style="color:#e6db74">&#34;parallel - test 1&#34;</span> , <span style="color:#f92672">|</span>b<span style="color:#f92672">|</span> b.iter(<span style="color:#f92672">||</span> euler1_par(black_box(input))));
</span></span><span style="display:flex;"><span>    group.bench_function( <span style="color:#e6db74">&#34;series - test 1&#34;</span>, <span style="color:#f92672">|</span>b<span style="color:#f92672">|</span> b.iter(<span style="color:#f92672">||</span> euler1_series(black_box(input))));
</span></span><span style="display:flex;"><span>    group.finish();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>criterion_group!(benches, criterion_benchmark);
</span></span><span style="display:flex;"><span>criterion_main!(benches);
</span></span></code></pre></div><p>In the above code, we follow nearly the same process as individual benchmarking, except we first create and name a <code>BenchmarkGroup</code> using <code>c.benchmark_group(name)</code>, which is merely an entity used to group related benchmarks for analysis and reporting. The compiled output is available at <code>$PROJECT/target/criterion/Euler 1/report/index.html</code>, while individual reports for each function are available at <code>$PROJECT/target/criterion/Euler1/{benchmark-name}/report/index.html</code>.</p>
<!-- raw HTML omitted -->
<h3 id="criterioncriterionbench_with_input">criterion::Criterion::bench_with_input</h3>
<p>To thoroughly benchmark a function, it&rsquo;s important to test it across a range of acceptable values. <code>bench_with_input</code> helps test a wide range of cases more effectively.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> criterion_benchmarking::{euler1_par, euler1_series, euler1_simple};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">criterion_benchmark</span>(c: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Criterion) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> inputs <span style="color:#f92672">=</span> [<span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">1000</span>, <span style="color:#ae81ff">10000</span>, <span style="color:#ae81ff">100000</span>, <span style="color:#ae81ff">1000000</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> group <span style="color:#f92672">=</span> c.benchmark_group(<span style="color:#e6db74">&#34;Multiple inputs&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> inputs {
</span></span><span style="display:flex;"><span>        group.bench_with_input(BenchmarkId::new(<span style="color:#e6db74">&#34;euler1_simple&#34;</span>, i), <span style="color:#f92672">&amp;</span>i, <span style="color:#f92672">|</span>b, <span style="color:#f92672">&amp;</span>i<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>            b.iter(<span style="color:#f92672">||</span> euler1_simple(black_box(i)))
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>        group.bench_with_input(BenchmarkId::new(<span style="color:#e6db74">&#34;euler1_par&#34;</span>, i), <span style="color:#f92672">&amp;</span>i, <span style="color:#f92672">|</span>b, <span style="color:#f92672">&amp;</span>i<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>            b.iter(<span style="color:#f92672">||</span> euler1_par(black_box(i)))
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>        group.bench_with_input(BenchmarkId::new(<span style="color:#e6db74">&#34;euler1_series&#34;</span>, i), <span style="color:#f92672">&amp;</span>i, <span style="color:#f92672">|</span>b, <span style="color:#f92672">&amp;</span>i<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>            b.iter(<span style="color:#f92672">||</span> euler1_series(black_box(i)))
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    group.finish();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>criterion_group!(benches, criterion_benchmark);
</span></span><span style="display:flex;"><span>criterion_main!(benches);
</span></span></code></pre></div><p>Note that we added <code>BenchmarkId</code> to the <code>use</code> declaration for <em>Criterion</em>. Next, we create an array of input values to assess, as well as a new <code>BenchmarkGroup</code>. We then iterate across the array of inputs, and call <code>bench_with_input</code> with a unique <code>BenchmarkId</code> and a closure that passes input <code>i</code> to the function being tested.</p>
<!-- raw HTML omitted -->
<p>A summary of all of our reports so far is available at <code>$PROJECT/criterion/report/index.html</code>. The tabular format for the <em>Multiple inputs</em> tests is a great way to compare multiple functions across a range of inputs, as well as slice the data by two explanatory variables - the function and the input. This level of detail allows us to explore relationships between multiple explanatory variables using a concept called <a href="https://en.wikipedia.org/wiki/Response_surface_methodology">Response Surface Methodology</a>. Unfortunately, Criterion is currently lacking in the abilty to generate 3-dimensional graphs needed to explore this concept in more detail.</p>
<p>Benchmarking across a wide range of inputs helps you find use cases that suffer from sub-optimal performance. For example, I found that <code>euler1_simple</code> and <code>euler1_par</code> take a significant amount of time to process the maximum value available in <code>i64</code>, ~$9.22 * 10^{18}$, indicating that these functions should be modified to accept an integer type with a smaller number space as an input parameter.</p>
<h1 id="final-thoughts">Final Thoughts</h1>
<p>If you write code for a living, chances are that someone else will have to reference, re-use, or adapt your code for another purpose in the future. Therefore, it&rsquo;s important to be a good custodian of the code you write by considering performance and ensuring it can function as expected through the range of its intended use conditions and beyond. Benchmarking is a key tool for understanding how your code functions under the hood and making improvements in a scientific manner.</p>
<p>The benchmarking process is highly sensitive to the testing environment, so great care should be taken to ensure that tests are conducted in as similar environment to each other as possible, for example on the same machine with similar background loads between tests.</p>
<p>I have found Rust to be incredibly well-documented, among the best I&rsquo;ve encountered in my career. The Criterion library is no exception, and as a result a lot of the material for this article was derived from the <a href="https://bheisler.github.io/criterion.rs/book/getting_started.html">original documentation</a> for <em>Criterion</em>.</p>
<p><em>This article was originally written for the <a href="https://engineering.deptagency.com/benchmarking-rust-code-using-criterion-rs">engineering blog</a> at DEPT¬Æ, a technology consultancy</em></p>

  


  </main>
  <footer class="pt-8">
    <p>Copyright 2024. All rights reserved.</p>
<p>Handmade with <a href="https://gohugo.io/">Hugo</a> and <a href="https://tailwindcss.com/">Tailwind</a>.</p>

  </footer>
</body>
</html>
